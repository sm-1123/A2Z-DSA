---------------------------date:24/06/2024---------------------------------------------------

P1:Floyd Warshall[TC:O(V^3),SC:O(V^2)]

def floydWarshall(n, m, src, dest, edges):

    dist = [[1000000000] * n for _ in range(n)]

    for i in range(n):

        dist[i][i] = 0

    for i in range(m):

        u, v, w = edges[i]

        dist[u - 1][v - 1] = w            

    for k in range(n):

        for i in range(n):

            for j in range(n):

                if dist[i][k] != 1000000000 and dist[k][j] != 1000000000:

                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist[src - 1][dest - 1]    

    # Write your code here.

-----------------------------------date:25/06/2024---------------------------------------------

P2:Bellman Ford[TC:O(V*E), SC:O(V)]

def bellmonFord(n, m, src, edges):
    # Write your code here.
    dist = [100000000] * (n + 1)

    dist[src] = 0

    for i in range(1, n):

        for j in range(m):

            u = edges[j][0]

            v = edges[j][1]

            w = edges[j][2]

            if dist[u] + w < dist[v]:

                dist[v] = dist[u] + w   

    return dist
    
P3:Check Bipartite Graph[TC:O(V + 2E), SC:O(3V)]

from collections import deque

def bfs(i, color, adj):

    q = deque()

    color[i] = 0

    q.append(i)

    while q:

        node = q.popleft()

        for neighbor in adj[node]:

            if color[neighbor] == -1:

                color[neighbor] = 1 - color[node]

                q.append(neighbor)

            elif color[neighbor] == color[node]:

                return False

    return True                

def isGraphBirpartite(edges):

    n = len(edges)

    color = [-1] * n

    adj = [[] for _ in range(n)]

    for i in range(n):

        for j in range(n):

            if edges[i][j]:

                adj[i].append(j)

                adj[j].append(i)

    for i in range(n):

        if color[i] == -1:

            if not bfs(i, color, adj):

                return False

    return True

    #Write your code here.
    
P4:Detect Cycle In A Directed Graph[TC:O(V + E), SC:O(V + E)]

def chkCycDFS(adjList, vis, dfsVis, node):

    vis[node] = True

    dfsVis[node] = True

    if node in adjList:

        for neighbor in adjList[node]:

            if not vis[neighbor]:

                if chkCycDFS(adjList, vis, dfsVis, neighbor):

                    return True

            elif dfsVis[neighbor]:

                return True

    dfsVis[node] = False

    return False                    

def detectCycleInDirectedGraph(n, edges):
    # Write your code here

    adjList = {}

    vis = {i : False for i in range(1, n + 1)}

    dfsVis = {j : False for j in range(1, n + 1)}

    for edge in edges:

        u = edge[0]

        v = edge[1]

        if u not in adjList:

            adjList[u] = []

        adjList[u].append(v)

    for i in range(1, n + 1):

        if not vis[i]:

            if chkCycDFS(adjList, vis, dfsVis, i):

                return True

    return False

    pass

P5:M-Coloring Problem[TC:O(N^M), SC:O(N)]

from typing import *

def isSafe(node, color, mat, n, col):

    for k in range(n):

        if k != node and mat[k][node] == 1 and color[k] == col:

            return False

    return True

def solve(node, color, m, n, mat):

    if node == n:

        return True

    for i in range(1, m + 1):

        if isSafe(node, color, mat, n, i):

            color[node] = i

            if solve(node + 1, color, m, n, mat):

                return True

            color[node] = 0    

    return False                

def graphColoring(mat: List[List[int]], m: int) -> str:

    n = len(mat)

    color = [0] * n

    if solve(0, color, m, n, mat):

        return "YES"

    return "NO"

    # Write your code here

    pass 

P6:Topological Sort[TC:O(V + E), SC:O(V + E)]

def dfs(node, vis, stk, adj_list):

    vis[node] = True

    for neighbor in adj_list[node]:

        if not vis[neighbor]:

            dfs(neighbor, vis, stk, adj_list)

    stk.append(node)        

def topologicalSort(adj, v, e):

    adj_list = {}

    for i in range(v):

        adj_list[i] = []

    for i in range(e):

        u, w = adj[i]

        adj_list[u].append(w)

    vis = [False] * v

    stk = []

    for i in range(v):

        if not vis[i]:

            dfs(i, vis, stk, adj_list)

    stk.reverse()

    return stk    

    # Write your code here

    pass
