----------------------date:07/06/2024----------------------------------------------
P1:Frog Jump
SOL1:Memoization Approach[TC:O(N),SC:(O(N)for recur stack space + O(N)for dp array)]
import sys
import math
def solve(ind, heights, dp):
    if ind == 0:
        return 0
    if dp[ind] != -1:
        return dp[ind]
    jumpTwo = sys.maxsize
    jumpOne = solve(ind-1, heights, dp) + abs(heights[ind] - heights[ind-1])
    if ind > 1:
        jumpTwo = solve(ind-2, heights, dp) + abs(heights[ind] - heights[ind-2])
    dp[ind] = min(jumpOne, jumpTwo)
    return dp[ind]

if __name__ == "__main__":
    heights = [int(x) for x in input("enter height separated by spaces: ").split()]
    n = len(heights)
    dp = [-1] * n
    print(solve(n-1, heights, dp))

SOL2:Tabulation Approach[TC:O(N),SC:O(N)only array space]
import sys
import math
def main():
    heights = [int(x) for x in input("enter height separated by spaces: ").split()]
    n = len(heights)
    dp = [-1 for _ in range(n)]
    dp[0] = 0
    for ind in range(1,n):
        jumpTwo = float('inf')
        jumpOne = dp[ind-1] + abs(heights[ind] - heights[ind-1])
        if ind > 1:
            jumpTwo = dp[ind-2] + abs(heights[ind] - heights[ind-2])
        dp[ind] = min(jumpOne, jumpTwo)
    print(dp[n-1])

if __name__ == "__main__":
    main()

SOL3:Space Optimization Approach[TC:O(N),O(1)]
import sys
import math
def main():
    heights = [int(x) for x in input("enter height separated by spaces: ").split()]
    n = len(heights)
    prev = 0
    prev2 = 0
    for i in range(1,n):
        jumpTwo = sys.maxsize
        jumpOne = prev + abs(heights[i] - heights[i-1])
        if i > 1:
            jumpTwo = prev2 + abs(heights[i] - heights[i-2])
        curr_i = min(jumpOne, jumpTwo)
        prev2 = prev
        prev = curr_i
    print(prev)

if __name__ == "__main__":
    main()

P2:Minimal Cost
Memoization Approach-[TC:O(N*K),SC:O(N)]
import sys
def solveUtil(height, ind, k, dp):
    if ind == 0:
        return 0
    if dp[ind] != -1:
        return dp[ind]
    mmSteps = sys.maxsize
    for j in range(1,k+1):
        if ind - j >= 0:
            jump = solveUtil(height, ind-j, k, dp) + abs(height[ind] - height[ind-j])
            mmSteps = min(jump, mmSteps)
    dp[ind] = mmSteps
    return mmSteps

def solve(height, n, k):
    dp = [-1] * n
    return solveUtil(height, n-1, k, dp)
def main():
    height = [int(x) for x in input("enter height separated by spaces: ").split()]
    n = len(height)
    k = int(input("enter k value: "))
    print(solve(height, n, k))

if __name__ == "__main__":
    main()

Tabulation Approach:[TC:O(N*K),SC:O(N)]
import sys
def solveUtil(height, n, k, dp):
    dp[0] = 0

    for i in range(1,n):
        mmSteps = sys.maxsize
        for j in range(1,k+1):
            if i - j >= 0:
                jump = dp[i-j] + abs(height[i] - height[i-j])
                mmSteps = min(jump, mmSteps)
            dp[i] = mmSteps
    return dp[n-1]

def solve(height, n, k):
    dp = [-sys.maxsize] * n
    return solveUtil(height, n, k, dp)
def main():
    height = [int(x) for x in input("enter height separated by spaces: ").split()]
    n = len(height)
    k = int(input("enter k value: "))
    result = solve(height, n, k)
    print(result)

if __name__ == "__main__":
    main()

--------------------------------date:09/06/2024---------------------------------
P3:Maximum sum of non-adjacent elements (DP 5)[TC:O(N),SC:O(N)+O(N)---O(N)]....

M1:Memoization Approach

import sys

def solveUtil(nums, ind, dp):

    if dp[ind] != -1:
        return dp[ind]

    if ind == 0:
        return nums[ind]

    if ind < 0:
        return 0

    pick = nums[ind] + solveUtil(nums, ind-2, dp)

    nonPick = 0 + solveUtil(nums, ind-1, dp)

    dp[ind] = max(pick, nonPick)

    return dp[ind]

def solve(nums, n):

    dp = [-1] * n

    return solveUtil(nums, n-1, dp)
def main():

    nums = [int(x) for x in input("enter nums separated by spaces: ").split()]

    n = len(nums)

    result = solve(nums, n)

    print(result)

if __name__ == "__main__":

    main()

M2:Tabulation Approach[TC:O(N)Iterative Loop,SC:O(N)Array of size n+1]

import sys

def solveUtil(nums, n, dp):

    dp[0] = nums[0]

    for i in range(1, n):

        pick = nums[i]

        if i > 1:

            pick += dp[i-2]

        nonPick = 0 + dp[i-1]

        dp[i] = max(pick, nonPick)

    return dp[n-1]

def solve(nums, n):

    dp = [-1] * n

    return solveUtil(nums, n, dp)
def main():

    nums = [int(x) for x in input("enter nums separated by spaces: ").split()]

    n = len(nums)

    result = solve(nums, n)

    print(result)

if __name__ == "__main__":

    main()

M3:Space Optimization[TC:O(N)-iterative loop,SC:O(1)]

import sys

def solve(nums, n):

    prev = nums[0]

    prev2 = 0

    for i in range(1, n):

        pick = nums[i]

        if i > 1:

            pick += prev2

        nonPick = 0 + prev

        curr_i = max(pick, nonPick)

        prev2 = prev

        prev = curr_i

    return prev

def main():

    nums = [int(x) for x in input("enter nums separated by spaces: ").split()]

    n = len(nums)

    result = solve(nums, n)

    print(result)

if __name__ == "__main__":

    main()

P4:House Robber 2:[TC;O(N) + O(N)..Two times iter loop, SC:O(1)]

import sys
def solve(nums):

    n = len(nums)

    if n == 0:

        return 0

    if n == 1:

        return nums[0]

    prev = nums[0]

    prev2 = 0

    for i in range(1, n):

        pick = nums[i]

        if i > 1:

            pick += prev2

        nonPick = 0 + prev

        curr_i = max(pick, nonPick)

        prev2 = prev

        prev = curr_i

    return prev

def robStreet(nums, n):

    arr1 = []

    arr2 = []

    if n == 1:

        return nums[0]

    for i in range(n):

        if i != 0:

            arr1.append(nums[i])

        if i != n-1:

            arr2.append(nums[i])

        ans1 = solve(arr1)

        ans2 = solve(arr2)

    return max(ans1, ans2)
def main():

    nums = [int(x) for x in input("enter nums separated by spaces: ").split()]

    n = len(nums)

    result = robStreet(nums, n)

    print(result)

if __name__ == "__main__":

    main()
